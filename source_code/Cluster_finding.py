# -*- coding: utf-8 -*-
"""Microbioma.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/16EY04BZBeIRzoFkLXa7q8L97NTf0RTD-

La reproducció no és només cosa de dos: hackejant els secrets del microbioma seminal
-----

Imports
"""

# Commented out IPython magic to ensure Python compatibility.
#Datasets
#   https://ddd.uab.cat/record/258024
#   https://dataverse.csuc.cat/dataset.xhtml?persistentId=doi:10.34810/data680
# Extra:  https://www.npatlas.org/about

# https://bitslive.hackersatupc.org/


import pandas as pd
import numpy as np
import csv
# %matplotlib inline
import matplotlib.pyplot as plt
import seaborn as sns; sns.set()  # for plot styling
from tqdm import tqdm

"""Read the file"""

family_data=pd.read_csv('Dataset/Ilumina/Metadata_and_relative_abundance_of_seminal_microbiota_from_idiopathic_infertile_patients_and_donors.xlsx - Family-level microbiota.csv', na_values=['#DIV/0!'])
genus_data=pd.read_csv('Dataset/Ilumina/Metadata_and_relative_abundance_of_seminal_microbiota_from_idiopathic_infertile_patients_and_donors.xlsx - Genus-level microbiota.csv', na_values=['#DIV/0!'])
pylum_data=pd.read_csv('Dataset/Ilumina/Metadata_and_relative_abundance_of_seminal_microbiota_from_idiopathic_infertile_patients_and_donors.xlsx - Pylum-level microbiota.csv', na_values=['#DIV/0!'])
metadata=pd.read_csv('Dataset/Ilumina/Metadata_and_relative_abundance_of_seminal_microbiota_from_idiopathic_infertile_patients_and_donors.xlsx - Sample info + Sperm quality.csv', na_values=['#DIV/0!'])
pd.set_option('display.max_columns', None)
pd.options.display.max_columns = None
pd.options.display.max_rows = None


metadata["Clinical status"]= metadata["Clinical status"].apply(lambda x: 0 if x=="Infertile" else 1)
metadata["Alcohol intake"]= metadata["Alcohol intake"].apply(lambda x: 0 if x=="Never" else 1 if x=="Sporadic" else 2 if x=="Frequent" else None)
metadata["Antibiotics (last month)"]= metadata["Antibiotics (last month)"].apply(lambda x: 1 if x=="Yes" else 0)
metadata.loc[metadata['Clinical status'] == "UAB 17010", 'Antibiotics (last month)'] = None

metadata["City of residence 1"] = pd.factorize(metadata["City of residence 1"])[0] + 1

metadata_pylum_relation = pd.merge(metadata[["Clinical status", "Age", "Sample ID", "Alcohol intake", "Antibiotics (last month)", "Smoker", "Caffeine (mg/day)", "Radiation exposure", "Chemical exposure", "Total sperm number (x10^6)", "Volume (mL)", "Shannon Index"]],pylum_data , on = 'Sample ID' , how = 'inner')
metadata_family_relation = pd.merge(metadata[["Clinical status", "Age", "Sample ID", "Alcohol intake", "Antibiotics (last month)", "Smoker", "Caffeine (mg/day)", "Radiation exposure", "Chemical exposure", "Total sperm number (x10^6)", "Volume (mL)", "Shannon Index"]],family_data , on = 'Sample ID' , how = 'inner')
metadata_genus_relation = pd.merge(metadata[["Clinical status", "Age", "Sample ID", "Alcohol intake", "Antibiotics (last month)", "Smoker", "Caffeine (mg/day)", "Radiation exposure", "Chemical exposure", "Total sperm number (x10^6)", "Volume (mL)", "Shannon Index"]],genus_data , on = 'Sample ID' , how = 'inner')

target_column = ["Clinical status", "Age", "Alcohol intake", "Antibiotics (last month)", "Smoker", "Caffeine (mg/day)", "Radiation exposure", "Chemical exposure", "Total sperm number (x10^6)", "Volume (mL)", "Shannon Index"] 

for i in (range(3)):
    print("######################################################################################")
    if (i == 0):
        print("Correlations among cluster of microbiotes and targets")

        # Create correlation matrix Family-Metadata
        corr_matrix = metadata_pylum_relation.corr(numeric_only=True).abs()
        #plt.figure(figsize=(100, 100))
        #sns.heatmap(corr_matrix)
        #plt.savefig('heatmap_family.png', dpi=400, bbox_inches='tight')

        high_corr_var=np.where(corr_matrix>0.60)
        high_corr_var=[(corr_matrix.columns[x],corr_matrix.columns[y]) for x,y in zip(*high_corr_var) if x!=y and x<y]
        

        # Create a dictionary to store relationships for each unique element
        relationships_dict = {}

        for correlation in high_corr_var:
            element1, element2 = correlation

            if element2 not in target_column:
                # Store relationships for element1
                if element1 not in relationships_dict:
                    relationships_dict[element1] = [element2]
                else:
                    relationships_dict[element1].append(element2)


            if element1 not in target_column:
                # Store relationships for element2
                if element2 not in relationships_dict:
                    relationships_dict[element2] = [element1]
                else:
                    relationships_dict[element2].append(element1)
            
        count = 0
        # Calculate correlations
        for elem in relationships_dict:
            relationships = relationships_dict[elem]
            found = False
            
            # Iterate over subsets of the relationships list
            for i in range(len(relationships), 0, -1):
                subset = relationships[-i:]

                # Iterate over target columns
                for target in target_column:
                    if elem != target:
                        # Extract the relevant columns from the DataFrame
                        relevant_columns = [elem, target] + subset
                        subset_df = metadata_pylum_relation[relevant_columns]

                        # Calculate individual correlations
                        correlation_elem_target = subset_df.corr().iloc[0, 1]
                        correlation_subset_target = subset_df.corr().iloc[2:, 1].abs().min()

                        # Check if the correlation still satisfies towards the target
                        if correlation_elem_target > 0.60 and correlation_subset_target > 0.60:
                            print(f"Correlation between {elem}, {subset} with {target}: {correlation_elem_target}")
                            count += 1
                            found = True
                    
                    if found:
                        break
        print(count)

        
    elif (i == 1):
        print("Correlations among cluster of different microbiotes and targets")

        # Create correlation matrix Family-Metadata
        corr_matrix = metadata_family_relation.corr(numeric_only=True).abs()
        #plt.figure(figsize=(100, 100))
        #sns.heatmap(corr_matrix)
        #plt.savefig('heatmap_family.png', dpi=400, bbox_inches='tight')

        high_corr_var=np.where(corr_matrix>0.60)
        high_corr_var=[(corr_matrix.columns[x],corr_matrix.columns[y]) for x,y in zip(*high_corr_var) if x!=y and x<y]

        # Create a dictionary to store relationships for each unique element
        relationships_dict = {}

        for correlation in high_corr_var:
            element1, element2 = correlation

            if element2 not in target_column:
                # Store relationships for element1
                if element1 not in relationships_dict:
                    relationships_dict[element1] = [element2]
                else:
                    relationships_dict[element1].append(element2)


            if element1 not in target_column:
                # Store relationships for element2
                if element2 not in relationships_dict:
                    relationships_dict[element2] = [element1]
                else:
                    relationships_dict[element2].append(element1)
            
        count = 0
        # Calculate correlations
        for elem in relationships_dict:
            relationships = relationships_dict[elem]
            found = False

            # Iterate over subsets of the relationships list
            for i in range(len(relationships), 0, -1):
                subset = relationships[-i:]

                # Iterate over target columns
                for target in target_column:
                    if elem != target:
                        # Extract the relevant columns from the DataFrame
                        relevant_columns = [elem, target] + subset
                        subset_df = metadata_family_relation[relevant_columns]

                        # Calculate individual correlations
                        correlation_elem_target = subset_df.corr().iloc[0, 1]
                        correlation_subset_target = subset_df.corr().iloc[2:, 1].abs().min()

                        # Check if the correlation still satisfies towards the target
                        if correlation_elem_target > 0.60 and correlation_subset_target > 0.60:
                            print(f"Correlation between {elem}, {subset} with {target}: {correlation_elem_target}")
                            count += 1
                            found = True
                    
                    if found:
                        break
        print(count)

    else:
        print("Correlations among cluster of different microbiotes and targets")

        # Create correlation matrix Family-Metadata
        corr_matrix = metadata_genus_relation.corr(numeric_only=True).abs()
        #plt.figure(figsize=(100, 100))
        #sns.heatmap(corr_matrix)
        #plt.savefig('heatmap_family.png', dpi=400, bbox_inches='tight')

        high_corr_var=np.where(corr_matrix>0.60)
        high_corr_var=[(corr_matrix.columns[x],corr_matrix.columns[y]) for x,y in zip(*high_corr_var) if x!=y and x<y]

        # Create a dictionary to store relationships for each unique element
        relationships_dict = {}

        for correlation in high_corr_var:
            element1, element2 = correlation

            if element2 not in target_column:
                # Store relationships for element1
                if element1 not in relationships_dict:
                    relationships_dict[element1] = [element2]
                else:
                    relationships_dict[element1].append(element2)


            if element1 not in target_column:
                # Store relationships for element2
                if element2 not in relationships_dict:
                    relationships_dict[element2] = [element1]
                else:
                    relationships_dict[element2].append(element1)
            
        count = 0
        # Calculate correlations
        for elem in relationships_dict:
            relationships = relationships_dict[elem]
            found = False
            
            # Iterate over subsets of the relationships list
            for i in range(len(relationships), 0, -1):
                subset = relationships[-i:]

                # Iterate over target columns
                for target in target_column:
                    if elem != target:
                        # Extract the relevant columns from the DataFrame
                        relevant_columns = [elem, target] + subset
                        subset_df = metadata_genus_relation[relevant_columns]

                        # Calculate individual correlations
                        correlation_elem_target = subset_df.corr().iloc[0, 1]
                        correlation_subset_target = subset_df.corr().iloc[2:, 1].abs().min()

                        # Check if the correlation still satisfies towards the target
                        if correlation_elem_target > 0.60 and correlation_subset_target > 0.60:
                            print(f"Correlation between {elem}, {subset} with {target}: {correlation_elem_target}")
                            count += 1
                            found = True
                    
                    if found:
                        break
        print(count)

        


#sns.set(style="ticks", color_codes=True)
#sns.pairplot(metadata_pylum_relation)